# baseURI: http://topbraid.org/spin/spinmapl
# imports: http://spinrdf.org/spinmap
# imports: http://topbraid.org/sparqlmotionfunctions

# c14n-version: 3
@prefix afn: <http://jena.hpl.hp.com/ARQ/function#> .
@prefix arg: <http://spinrdf.org/arg#> .
@prefix fn: <http://www.w3.org/2005/xpath-functions#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix smf: <http://topbraid.org/sparqlmotionfunctions#> .
@prefix sp: <http://spinrdf.org/sp#> .
@prefix spif: <http://spinrdf.org/spif#> .
@prefix spin: <http://spinrdf.org/spin#> .
@prefix spinmap: <http://spinrdf.org/spinmap#> .
@prefix spinmapl: <http://topbraid.org/spin/spinmapl#> .
@prefix spl: <http://spinrdf.org/spl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
spif:parseDate
  spinmap:suggestion-1-1 [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object spif:parseDate ;
            sp:predicate rdf:type ;
            sp:subject _:b95532 ;
          ]
          [
            sp:object [
                sp:varName "pattern"^^xsd:string ;
              ] ;
            sp:predicate arg:pattern ;
            sp:subject _:b95532 ;
          ]
          [
            sp:object [
                sp:varName "count"^^xsd:string ;
              ] ;
            sp:predicate spinmap:suggestionScore ;
            sp:subject _:b95532 ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "range"^^xsd:string ;
              ] ;
            sp:predicate rdfs:range ;
            sp:subject [
                sp:varName "targetPredicate1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:or ;
                sp:arg1 [
                    rdf:type sp:or ;
                    sp:arg1 [
                        rdf:type sp:eq ;
                        sp:arg1 [
                            sp:varName "range"^^xsd:string ;
                          ] ;
                        sp:arg2 xsd:date ;
                      ] ;
                    sp:arg2 [
                        rdf:type sp:eq ;
                        sp:arg1 [
                            sp:varName "range"^^xsd:string ;
                          ] ;
                        sp:arg2 xsd:dateTime ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:eq ;
                    sp:arg1 [
                        sp:varName "range"^^xsd:string ;
                      ] ;
                    sp:arg2 xsd:time ;
                  ] ;
              ] ;
          ]
          [
            sp:object spif:parseDate ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "fc"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "pattern"^^xsd:string ;
              ] ;
            sp:predicate arg:pattern ;
            sp:subject [
                sp:varName "fc"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "fc"^^xsd:string ;
              ] ;
            sp:predicate spl:testExpression ;
            sp:subject [
                sp:varName "testCase"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spinmapl:countInstancesWithDatePattern ;
                arg:pattern [
                    sp:varName "pattern"^^xsd:string ;
                  ] ;
                spinmapl:predicate [
                    sp:varName "sourcePredicate1"^^xsd:string ;
                  ] ;
                spinmapl:type [
                    sp:varName "sourceClass"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "count"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:gt ;
                sp:arg1 [
                    sp:varName "count"^^xsd:string ;
                  ] ;
                sp:arg2 0 ;
              ] ;
          ]
        ) ;
    ] ;
.
smf:dbpedia
  spinmap:suggestion-1-1 [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object smf:dbpedia ;
            sp:predicate rdf:type ;
            sp:subject [] ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:in ;
                sp:arg1 [
                    sp:varName "targetPredicate1"^^xsd:string ;
                  ] ;
                sp:arg2 owl:sameAs ;
                sp:arg3 rdfs:seeAlso ;
              ] ;
          ]
        ) ;
    ] ;
.
smf:setLanguage
  spinmap:suggestion-1-1 [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object smf:setLanguage ;
            sp:predicate rdf:type ;
            sp:subject _:b8405 ;
          ]
          [
            sp:object "en" ;
            sp:predicate arg:language ;
            sp:subject _:b8405 ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:in ;
                sp:arg1 [
                    sp:varName "targetPredicate1"^^xsd:string ;
                  ] ;
                sp:arg2 skos:prefLabel ;
                sp:arg3 skos:altLabel ;
              ] ;
          ]
        ) ;
    ] ;
.
<http://topbraid.org/spin/spinmapl>
  rdf:type owl:Ontology ;
  owl:imports <http://spinrdf.org/spinmap> ;
  owl:imports <http://topbraid.org/sparqlmotionfunctions> ;
  owl:versionInfo "1.0.0"^^xsd:string ;
.
spinmapl:Test-changeNamespace-1
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spinmapl:changeNamespace ;
      spinmap:source owl:Thing ;
      spinmapl:targetNamespace "http://example.org/test#" ;
    ] ;
  spl:testResult <http://example.org/test#Thing> ;
.
spinmapl:Test-fixedLengthPathParent-1
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spinmapl:fixedLengthPathParent ;
      sp:arg1 "W010203" ;
      spinmapl:segmentLength 2 ;
    ] ;
  spl:testResult "W0102"^^xsd:string ;
  rdfs:label "Test-fixed length path parent-1"^^xsd:string ;
.
spinmapl:Test-pathParent-1
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spinmapl:pathParent ;
      sp:arg1 "World > Europe > Germany" ;
      spinmapl:separator ">" ;
    ] ;
  spl:testResult "Europe"^^xsd:string ;
.
spinmapl:Test-pathParent-2
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spinmapl:pathParent ;
      sp:arg1 "Europe,Germany" ;
      spinmapl:separator "," ;
    ] ;
  spl:testResult "Europe"^^xsd:string ;
.
spinmapl:Test-pathParent-3
  rdf:type spl:TestCase ;
  spl:testExpression [
      rdf:type spinmapl:pathParent ;
      sp:arg1 "World" ;
      spinmapl:separator ">" ;
    ] ;
.
spinmapl:buildURI1
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    sp:varName "uri"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "value"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:buildURI ;
                sp:arg1 [
                    sp:varName "template"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "value"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property to get the value of."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:template ;
      spl:valueType xsd:string ;
      rdfs:comment "The template string, \"ex:Instance-{?1}\"."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  spinmap:shortLabel "build URI"^^xsd:string ;
  rdfs:comment "Builds a new URI using the value of a given property (?arg1) from a given subject (?source) and a given template (?template). The template may reference the value of the property using {?1}."^^xsd:string ;
  rdfs:label "build URI (with 1 argument)"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:buildURI2
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    sp:varName "uri"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "value1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "value2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:buildURI ;
                sp:arg1 [
                    sp:varName "template"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "value1"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    sp:varName "value2"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The first property to get the value of."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The second property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:template ;
      spl:valueType xsd:string ;
      rdfs:comment "The template string, \"ex:Instance-{?1}\"."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  spinmap:shortLabel "build URI"^^xsd:string ;
  rdfs:comment "Builds a new URI using the value of two given properties (?arg1, ?arg1) from a given subject (?source) and a given template (?template). The template may reference the values of the properties using {?1} and {?2}."^^xsd:string ;
  rdfs:label "build URI (with 2 arguments)"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:buildURI3
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    sp:varName "uri"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "value1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "value2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg3 ;
              ] ;
            sp:variable [
                sp:varName "value3"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:buildURI ;
                sp:arg1 [
                    sp:varName "template"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "value1"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    sp:varName "value2"^^xsd:string ;
                  ] ;
                sp:arg4 [
                    sp:varName "value3"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The first property to get the value of."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The second property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The third property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:template ;
      spl:valueType xsd:string ;
      rdfs:comment "The template string, \"ex:Instance-{?1}\"."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  spinmap:shortLabel "build URI"^^xsd:string ;
  rdfs:comment "Builds a new URI using the value of three given properties (?arg1, ?arg2, ?arg3) from a given subject (?source) and a given template (?template). The template may reference the values of the properties using {?1}, {?2} and {?3}."^^xsd:string ;
  rdfs:label "build URI (with 3 arguments)"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:buildURI4
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    sp:varName "uri"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "value1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "value2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg3 ;
              ] ;
            sp:variable [
                sp:varName "value3"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg4 ;
              ] ;
            sp:variable [
                sp:varName "value4"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:buildURI ;
                sp:arg1 [
                    sp:varName "template"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "value1"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    sp:varName "value2"^^xsd:string ;
                  ] ;
                sp:arg4 [
                    sp:varName "value3"^^xsd:string ;
                  ] ;
                sp:arg5 [
                    sp:varName "value4"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The first property to get the value of."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The second property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The third property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg4 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The forth property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:template ;
      spl:valueType xsd:string ;
      rdfs:comment "The template string, \"ex:Instance-{?1}\"."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  spinmap:shortLabel "build URI"^^xsd:string ;
  rdfs:comment "Builds a new URI using the value of four given properties (?arg1, ?arg2, ?arg3, ?arg4) from a given subject (?source) and a given template (?template). The template may reference the values of the properties using {?1}, {?2}, {?3} and {?4}."^^xsd:string ;
  rdfs:label "build URI (with 4 arguments)"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:buildURI5
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    sp:varName "uri"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "value1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg2 ;
              ] ;
            sp:variable [
                sp:varName "value2"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg3 ;
              ] ;
            sp:variable [
                sp:varName "value3"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg4 ;
              ] ;
            sp:variable [
                sp:varName "value4"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:object ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                sp:arg2 spin:_arg5 ;
              ] ;
            sp:variable [
                sp:varName "value5"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:buildURI ;
                sp:arg1 [
                    sp:varName "template"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "value1"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    sp:varName "value2"^^xsd:string ;
                  ] ;
                sp:arg4 [
                    sp:varName "value3"^^xsd:string ;
                  ] ;
                sp:arg5 [
                    sp:varName "value4"^^xsd:string ;
                  ] ;
                sp:arg6 [
                    sp:varName "value5"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The first property to get the value of."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The second property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg3 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The third property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg4 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The forth property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg5 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The firth property."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:template ;
      spl:valueType xsd:string ;
      rdfs:comment "The template string, \"ex:Instance-{?1}\"."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  spinmap:shortLabel "build URI"^^xsd:string ;
  rdfs:comment "Builds a new URI using the value of five given properties (?arg1, ?arg2, ?arg3, ?arg4, ?arg5) from a given subject (?source) and a given template (?template). The template may reference the values of the properties using {?1}, {?2}, {?3}, {?4} and {?5}."^^xsd:string ;
  rdfs:label "build URI (with 5 arguments)"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:changeNamespace
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "target"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type afn:localname ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "localName"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    rdf:type sp:concat ;
                    sp:arg1 [
                        sp:varName "targetNamespace"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "localName"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "target"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:targetNamespace ;
      spl:valueType xsd:string ;
      rdfs:comment "The target namespace."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "A target function that replaces the namespace of the source URI by a given target namespace."^^xsd:string ;
  rdfs:label "change namespace"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:composeURI
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type sp:iri ;
                sp:arg1 [
                    sp:varName "uri"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:localName ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "value"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:buildURI ;
                sp:arg1 [
                    sp:varName "template"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "value"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "uri"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:template ;
      spl:valueType xsd:string ;
      rdfs:comment "The template string, \"ex:Instance-{?1}\"."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  spinmap:shortLabel "build URI"^^xsd:string ;
  rdfs:comment "Builds a new URI using the local name of a given subject (?source) and a given template (?template). The template may reference the value of the local name using {?1}."^^xsd:string ;
  rdfs:label "compose URI"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:concatWithSeparator
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type xsd:string ;
                sp:arg1 [
                    sp:varName "untyped"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:concat ;
                sp:arg1 [
                    rdf:type xsd:string ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
                sp:arg2 [
                    sp:varName "separator"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    rdf:type xsd:string ;
                    sp:arg1 spin:_arg2 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "untyped"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The first value to concatenate."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      rdfs:comment "The second value to concatenate."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:separator ;
      spl:valueType xsd:string ;
      rdfs:comment "The separator to put between the two values."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Creates a string by concatenating the two arguments, with a given separator in between."^^xsd:string ;
  rdfs:label "concat with separator"^^xsd:string ;
  rdfs:subClassOf spl:StringFunctions ;
.
spinmapl:constantResource
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value (will be ignored)."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:result ;
      spl:valueType rdfs:Resource ;
      rdfs:comment "The result resource."^^xsd:string ;
    ] ;
  rdfs:comment "Simply returns a constant resource, independent of the input argument. This can be used to create a value whenever a given property at the source instance has a value."^^xsd:string ;
  rdfs:label "constant resource"^^xsd:string ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spinmapl:context
  rdf:type rdf:Property ;
  rdfs:label "context"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
spinmapl:countInstancesWithDatePattern
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:limit "100"^^xsd:long ;
      sp:resultVariables (
          [
            rdf:type sp:Count ;
            sp:expression [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "value"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "class"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "class"^^xsd:string ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:eq ;
                sp:arg1 [
                    rdf:type sp:datatype ;
                    sp:arg1 [
                        sp:varName "value"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:parseDate ;
                arg:pattern [
                    sp:varName "pattern"^^xsd:string ;
                  ] ;
                sp:arg1 [
                    sp:varName "value"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "result"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate arg:pattern ;
      spl:valueType xsd:string ;
      rdfs:comment "The pattern to try."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to test."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The type of instances."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:integer ;
  rdfs:label "count instances with date pattern"^^xsd:string ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spinmapl:first10Values
  rdf:type spin:MagicProperty ;
  spin:body [
      rdf:type sp:Select ;
      sp:limit "10"^^xsd:long ;
      sp:resultVariables (
          [
            sp:varName "value"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:TriplePath ;
            sp:object spin:_arg1 ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value"^^xsd:string ;
              ] ;
            sp:predicate spin:_arg2 ;
            sp:subject [
                sp:varName "instance"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The class to walk the instances of."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to get the objects of."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  rdfs:label "first10Values"^^xsd:string ;
  rdfs:subClassOf spin:MagicProperties ;
.
spinmapl:fixedLengthPathParent
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "result"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:strlen ;
                sp:arg1 spin:_arg1 ;
              ] ;
            sp:variable [
                sp:varName "length"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:gt ;
                sp:arg1 [
                    sp:varName "length"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "segmentLength"^^xsd:string ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type fn:substring ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 1 ;
                sp:arg3 [
                    rdf:type sp:sub ;
                    sp:arg1 [
                        sp:varName "length"^^xsd:string ;
                      ] ;
                    sp:arg2 [
                        sp:varName "segmentLength"^^xsd:string ;
                      ] ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The path expression, e.g. \"W010203\""^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:segmentLength ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of characters to remove from the end of the input string."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a given path consisting of fixed length segments, e.g. \"W010203\" and gets the parent path by removing a segment."^^xsd:string ;
  rdfs:label "fixed length path parent"^^xsd:string ;
  rdfs:subClassOf spl:StringFunctions ;
.
spinmapl:fixedLengthPathParentTarget
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type spinmap:targetResource ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                spinmap:context [
                    sp:varName "context"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "target"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spinmapl:fixedLengthPathParent ;
                sp:arg1 spin:_arg1 ;
                spinmapl:segmentLength [
                    sp:varName "segmentLength"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "parentName"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "parentName"^^xsd:string ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:subject ;
                sp:arg1 [
                    sp:varName "predicate"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "parentName"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "source"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The path expression."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:context ;
      spl:valueType spinmap:Context ;
      rdfs:comment "The context to use for deriving the target from the source instance."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate that holds the parent path value in the source instance."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:segmentLength ;
      spl:valueType xsd:integer ;
      rdfs:comment "The number of characters to remove from the end of the path expression."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the parent of a path expression (using the function fixedLengthPathParent) and finds a source instance with a matching value for a given property. Then it finds the target resource for that source instance."^^xsd:string ;
  rdfs:label "fixed length path parent target"^^xsd:string ;
  rdfs:subClassOf spl:StringFunctions ;
.
spinmapl:hasValueFloat
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1"^^xsd:string ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value"^^xsd:string ;
              ] ;
            sp:predicate spinmapl:first10Values ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type xsd:float ;
                sp:arg1 [
                    sp:varName "value"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "result"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The source class."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Helper function to determine whether xsd:float conversion can be called on at least one of the first 10 values of a given class/property pair."^^xsd:string ;
  rdfs:label "has value float"^^xsd:string ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spinmapl:hasValueInteger
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Ask ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "?1"^^xsd:string ;
              ] ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            sp:object spin:_arg2 ;
            sp:predicate rdf:first ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object () ;
            sp:predicate rdf:rest ;
            sp:subject [
                sp:varName "?1"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "value"^^xsd:string ;
              ] ;
            sp:predicate spinmapl:first10Values ;
            sp:subject [
                sp:varName "?0"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type xsd:integer ;
                sp:arg1 [
                    sp:varName "value"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "result"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "result"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The source class."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg2 ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property."^^xsd:string ;
    ] ;
  spin:private "true"^^xsd:boolean ;
  spin:returnType xsd:boolean ;
  rdfs:comment "Helper function to determine whether xsd:integer conversion can be called on at least one of the first 10 values of a given class/property pair."^^xsd:string ;
  rdfs:label "has value integer"^^xsd:string ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spinmapl:pathEnd
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            rdf:type sp:if ;
            sp:arg1 [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "last"^^xsd:string ;
                  ] ;
              ] ;
            sp:arg2 [
                rdf:type spif:trim ;
                sp:arg1 [
                    rdf:type smf:subString ;
                    arg:fromIndex [
                        rdf:type sp:add ;
                        sp:arg1 [
                            sp:varName "last"^^xsd:string ;
                          ] ;
                        sp:arg2 1 ;
                      ] ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
              ] ;
            sp:arg3 spin:_arg1 ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:lastIndexOf ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 [
                    sp:varName "separator"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "last"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The path expression."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:separator ;
      spl:valueType xsd:string ;
      rdfs:comment "The separator of path elements. Elements will be trimmed for white spaces, so the separator does not need to specify them."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a path expression such as \"World > Europe > Germany\" and gets the last element, e.g. \"Germany\" with separator \">\"."^^xsd:string ;
  rdfs:label "path end"^^xsd:string ;
  rdfs:subClassOf spl:StringFunctions ;
.
spinmapl:pathParent
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "parent"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:lastIndexOf ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 [
                    sp:varName "separator"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "last"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "last"^^xsd:string ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:lastIndexOf ;
                sp:arg1 spin:_arg1 ;
                sp:arg2 [
                    sp:varName "separator"^^xsd:string ;
                  ] ;
                sp:arg3 [
                    rdf:type sp:sub ;
                    sp:arg1 [
                        sp:varName "last"^^xsd:string ;
                      ] ;
                    sp:arg2 1 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "last1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type sp:if ;
                sp:arg1 [
                    rdf:type sp:bound ;
                    sp:arg1 [
                        sp:varName "last1"^^xsd:string ;
                      ] ;
                  ] ;
                sp:arg2 [
                    rdf:type sp:add ;
                    sp:arg1 [
                        sp:varName "last1"^^xsd:string ;
                      ] ;
                    sp:arg2 1 ;
                  ] ;
                sp:arg3 0 ;
              ] ;
            sp:variable [
                sp:varName "start"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spif:trim ;
                sp:arg1 [
                    rdf:type smf:subString ;
                    arg:fromIndex [
                        sp:varName "start"^^xsd:string ;
                      ] ;
                    arg:toIndex [
                        sp:varName "last"^^xsd:string ;
                      ] ;
                    sp:arg1 spin:_arg1 ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "parent"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The path expression."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:separator ;
      spl:valueType xsd:string ;
      rdfs:comment "The separator of path elements. Elements will be trimmed for white spaces, so the separator does not need to specify them."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  rdfs:comment "Takes a path expression such as \"World > Europe > Germany\" and gets the last but one element, e.g. \"Europe\" with separator \">\"."^^xsd:string ;
  rdfs:label "path parent"^^xsd:string ;
  rdfs:subClassOf spl:StringFunctions ;
.
spinmapl:pathParentTarget
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "target"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spinmapl:pathParent ;
                sp:arg1 spin:_arg1 ;
                spinmapl:separator [
                    sp:varName "separator"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "parentName"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type sp:bound ;
                sp:arg1 [
                    sp:varName "parentName"^^xsd:string ;
                  ] ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spl:subject ;
                sp:arg1 [
                    sp:varName "predicate"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "parentName"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "source"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Bind ;
            sp:expression [
                rdf:type spinmap:targetResource ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                spinmap:context [
                    sp:varName "context"^^xsd:string ;
                  ] ;
              ] ;
            sp:variable [
                sp:varName "target"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      spl:valueType xsd:string ;
      rdfs:comment "The path expression."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:context ;
      spl:valueType spinmap:Context ;
      rdfs:comment "The context to use for deriving the target from the source instance."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate that holds the parent path value in the source instance."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:separator ;
      spl:valueType xsd:string ;
      rdfs:comment "The path separator, e.g. \">\"."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Gets the parent of a path expression (using the function pathParent) and finds a source instance with a matching value for a given property. Then it finds the target resource for that source instance. This is a highly specialized function for a design pattern often used in spreadsheets, where one column contains the full path expression, and the other contains the name of the item."^^xsd:string ;
  rdfs:label "path parent target"^^xsd:string ;
  rdfs:subClassOf spl:StringFunctions ;
.
spinmapl:predicate
  rdf:type rdf:Property ;
  rdfs:label "predicate"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
spinmapl:relatedObjectContext
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            rdf:type spinmap:targetResource ;
            sp:arg1 [
                sp:varName "object"^^xsd:string ;
              ] ;
            spinmap:context [
                sp:varName "context"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "object"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "source"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:context ;
      spl:valueType spinmap:Context ;
      rdfs:comment "The Context to apply to the other source object."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to walk along to find the other source object."^^xsd:string ;
    ] ;
  rdfs:comment "From the source object, this function uses a given property (?predicate) to find a related source object, and then applies a given context on that related source object to build the target resource. This can be used if the source object that we really want is one step away from the current source object."^^xsd:string ;
  rdfs:label "related object context"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:relatedSubjectContext
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            rdf:type spinmap:targetResource ;
            sp:arg1 [
                sp:varName "subject"^^xsd:string ;
              ] ;
            spinmap:context [
                sp:varName "context"^^xsd:string ;
              ] ;
          ]
        ) ;
      sp:where (
          [
            sp:object [
                sp:varName "source"^^xsd:string ;
              ] ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:context ;
      spl:valueType spinmap:Context ;
      rdfs:comment "The Context to apply to the other source object."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to walk along to find the other source object."^^xsd:string ;
    ] ;
  rdfs:comment "From the source object, this function uses a given property (?predicate) to find a related source subject, and then applies a given context on that related source subject to build the target resource. This can be used if the source instance that we really want is one step away from the current source instance."^^xsd:string ;
  rdfs:label "related subject context"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:resourceWithValue
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "subject"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "t"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "t"^^xsd:string ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "subject"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:optional "true"^^xsd:boolean ;
      spl:predicate spinmapl:type ;
      spl:valueType rdfs:Class ;
      rdfs:comment "The (optional) type of the result object, to narrow down the search space."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The value to match against."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The property that must be used in the result resource."^^xsd:string ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "Takes a value (?arg1) and a property (?predicate), as well an optional type, and returns a resource that has the given value as object for the predicate. For example, this can be used to find an instance of the class Country that has \"Australia\" as its label."^^xsd:string ;
  rdfs:label "resource with value"^^xsd:string ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spinmapl:result
  rdf:type rdf:Property ;
  rdfs:label "result"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
spinmapl:segmentLength
  rdf:type rdf:Property ;
  rdfs:label "segment length"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
spinmapl:self
  rdf:type spinmap:TargetFunction ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:varName "source"^^xsd:string ;
          ]
        ) ;
      sp:where () ;
    ] ;
  spin:returnType rdfs:Resource ;
  rdfs:comment "A simple function that returns the source instance itself, reusing exactly the same URIs and blank node identifiers."^^xsd:string ;
  rdfs:label "self"^^xsd:string ;
  rdfs:subClassOf spinmap:TargetFunctions ;
.
spinmapl:selfJoin
  rdf:type spin:Function ;
  spin:body [
      rdf:type sp:Select ;
      sp:resultVariables (
          [
            sp:expression [
                rdf:type spinmap:targetResource ;
                sp:arg1 [
                    sp:varName "source"^^xsd:string ;
                  ] ;
                spinmap:context [
                    sp:varName "context"^^xsd:string ;
                  ] ;
              ] ;
            sp:varName "target"^^xsd:string ;
          ]
        ) ;
      sp:where (
          [
            sp:object spin:_arg1 ;
            sp:predicate [
                sp:varName "predicate"^^xsd:string ;
              ] ;
            sp:subject [
                sp:varName "source"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "sourceClass"^^xsd:string ;
              ] ;
            sp:predicate spinmap:sourceClass ;
            sp:subject [
                sp:varName "context"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:TriplePath ;
            sp:object [
                sp:varName "sourceClass"^^xsd:string ;
              ] ;
            sp:path [
                rdf:type sp:ModPath ;
                sp:modMax -2 ;
                sp:modMin 0 ;
                sp:subPath rdfs:subClassOf ;
              ] ;
            sp:subject [
                sp:varName "type"^^xsd:string ;
              ] ;
          ]
          [
            sp:object [
                sp:varName "type"^^xsd:string ;
              ] ;
            sp:predicate rdf:type ;
            sp:subject [
                sp:varName "source"^^xsd:string ;
              ] ;
          ]
        ) ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The value(s) that the source instance must have for the predicate."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:context ;
      spl:valueType spinmap:Context ;
      rdfs:comment "The context to create the result resource with."^^xsd:string ;
    ] ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate spinmapl:predicate ;
      spl:valueType rdf:Property ;
      rdfs:comment "The predicate to look for."^^xsd:string ;
    ] ;
  rdfs:comment "Can be used to construct \"self-join\" matches, where the result is a resource from the target ontology."^^xsd:string ;
  rdfs:label "self join"^^xsd:string ;
  rdfs:subClassOf spl:MiscFunctions ;
.
spinmapl:separator
  rdf:type rdf:Property ;
  rdfs:label "separator"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
spinmapl:suffix
  rdf:type rdf:Property ;
  rdfs:label "suffix"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
spinmapl:targetNamespace
  rdf:type rdf:Property ;
  rdfs:label "target namespace"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
spinmapl:template
  rdf:type rdf:Property ;
  rdfs:label "template"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
spinmapl:type
  rdf:type rdf:Property ;
  rdfs:label "type"^^xsd:string ;
  rdfs:subPropertyOf sp:arg ;
.
xsd:boolean
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value."^^xsd:string ;
    ] ;
  spin:returnType xsd:boolean ;
  rdfs:comment "As a SPARQL function, this converts a given node (?arg1) to an xsd:boolean literal."^^xsd:string ;
.
xsd:date
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value."^^xsd:string ;
    ] ;
  spin:returnType xsd:date ;
  rdfs:comment "As a SPARQL function, this converts a given node (?arg1) to an xsd:date literal."^^xsd:string ;
.
xsd:dateTime
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value."^^xsd:string ;
    ] ;
  spin:returnType xsd:dateTime ;
  rdfs:comment "As a SPARQL function, this converts a given node (?arg1) to an xsd:dateTime literal."^^xsd:string ;
.
xsd:float
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value."^^xsd:string ;
    ] ;
  spin:returnType xsd:float ;
  spinmap:suggestion-1-1 [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object xsd:float ;
            sp:predicate rdf:type ;
            sp:subject _:b96926 ;
          ]
          [
            sp:object 50 ;
            sp:predicate spinmap:suggestionScore ;
            sp:subject _:b96926 ;
          ]
        ) ;
      sp:where (
          [
            sp:object xsd:float ;
            sp:predicate rdfs:range ;
            sp:subject [
                sp:varName "targetPredicate1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type spinmapl:hasValueFloat ;
                sp:arg1 [
                    sp:varName "sourceClass"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "sourcePredicate1"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "As a SPARQL function, this converts a given node (?arg1) to an xsd:float literal."^^xsd:string ;
.
xsd:integer
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value."^^xsd:string ;
    ] ;
  spin:returnType xsd:integer ;
  spinmap:suggestion-1-1 [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object xsd:integer ;
            sp:predicate rdf:type ;
            sp:subject _:b26191 ;
          ]
          [
            sp:object 50 ;
            sp:predicate spinmap:suggestionScore ;
            sp:subject _:b26191 ;
          ]
        ) ;
      sp:where (
          [
            sp:object xsd:integer ;
            sp:predicate rdfs:range ;
            sp:subject [
                sp:varName "targetPredicate1"^^xsd:string ;
              ] ;
          ]
          [
            rdf:type sp:Filter ;
            sp:expression [
                rdf:type spinmapl:hasValueInteger ;
                sp:arg1 [
                    sp:varName "sourceClass"^^xsd:string ;
                  ] ;
                sp:arg2 [
                    sp:varName "sourcePredicate1"^^xsd:string ;
                  ] ;
              ] ;
          ]
        ) ;
    ] ;
  rdfs:comment "As a SPARQL function, this converts a given node (?arg1) to an xsd:integer literal."^^xsd:string ;
.
xsd:string
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input node."^^xsd:string ;
    ] ;
  spin:returnType xsd:string ;
  spinmap:suggestion-1-1 [
      rdf:type sp:Construct ;
      sp:templates (
          [
            sp:object xsd:string ;
            sp:predicate rdf:type ;
            sp:subject _:b991 ;
          ]
          [
            sp:object 1 ;
            sp:predicate spinmap:suggestionScore ;
            sp:subject _:b991 ;
          ]
        ) ;
      sp:where (
          [
            sp:object xsd:string ;
            sp:predicate rdfs:range ;
            sp:subject [
                sp:varName "targetPredicate1"^^xsd:string ;
              ] ;
          ]
        ) ;
      rdfs:comment "Any value can be converted to xsd:string, so this is always a fall-back"^^xsd:string ;
    ] ;
  rdfs:comment "As a SPARQL function, this converts a given node (?arg1) to an xsd:string literal. If the input is a resource, then the URI of that resource will be returned."^^xsd:string ;
.
xsd:time
  rdf:type spin:Function ;
  spin:constraint [
      rdf:type spl:Argument ;
      spl:predicate sp:arg1 ;
      rdfs:comment "The input value."^^xsd:string ;
    ] ;
  spin:returnType xsd:time ;
  rdfs:comment "As a SPARQL function, this converts a given node (?arg1) to an xsd:time literal."^^xsd:string ;
.
